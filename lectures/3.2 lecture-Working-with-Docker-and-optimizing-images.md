# Course dev - Working-with-Docker-and-optimizing-images    - (Sasha )
# Сборка образа Docker

Команда `docker build` создает образ из Dockerfile и контекста сборки.  
Контекст сборки — это файлы, расположенные либо в локальной директории (PATH), либо в удалённом Git-репозитории (URL).

- Контекст обрабатывается рекурсивно:  
  - PATH включает все поддиректории  
  - URL включает репозиторий и его подмодули

Пример простой команды для создания образа с текущей директорией и её контекстом:

docker build .

![image](https://github.com/user-attachments/assets/9278fe95-8e87-4444-8188-c6b2327f3707)


---

## Как работает сборка

- Сборка запускается Docker-демоном, а не CLI.  
- Процесс сборки рекурсивно отправляет весь контекст демону.  
- Рекомендуется использовать минимально необходимый контекст — пустой каталог с Dockerfile и только нужными файлами.

> **Внимание:**  
> Не используйте корневую директорию `/` в качестве контекста — это приведёт к передаче всего содержимого жёсткого диска демону.

---

## Использование файлов в контексте

- Для работы с файлами в Dockerfile применяются инструкции, например, `COPY`.  
- Для исключения ненужных файлов из контекста создайте файл `.dockerignore` и укажите в нём каталоги и файлы, которые не должны передаваться.

Dockerfile по умолчанию размещается в корне контекста. Чтобы указать другое расположение, используйте флаг `-f`:

docker build -f path/to/Dockerfile .
![image](https://github.com/user-attachments/assets/1e617cad-8bbc-40f1-9e09-1e6487afbde3)



---

## Тегирование образа

Чтобы сохранить образ с именем и тегом, используйте опцию `-t`:
![image](https://github.com/user-attachments/assets/0b9705c3-3879-46be-b1b3-19711391555e)


docker build -t myimage:latest .



---

## Работа Docker-демона

- Демон выполняет инструкции Dockerfile последовательно.  
- После каждой инструкции создаётся промежуточный образ (если необходимо).  
- По окончании выводится ID нового образа.  
- Демон автоматически очищает переданный контекст.

---

# Разница между CMD и ENTRYPOINT

| Параметр   | Описание                                                                                      |
|------------|-----------------------------------------------------------------------------------------------|
| **CMD**    | Задаёт параметры по умолчанию, которые можно изменить при запуске контейнера через CLI.       |
| **ENTRYPOINT** | Определяет фиксированную команду, которая всегда выполняется при запуске контейнера. Аргументы запуска добавляются к ней. |

**Итог:**  
- `CMD` — для параметров по умолчанию, которые можно переопределить.  
- `ENTRYPOINT` — для базовой команды, которую нельзя изменить, но к ней можно добавлять аргументы.

---

# Инструкция EXPOSE

Инструкция `EXPOSE` указывает порты внутри контейнера, которые используются для связи. Она **не открывает порты** на хосте, а служит документацией.

**Особенности:**

- Поддерживает протоколы TCP (по умолчанию) и UDP.  
- Не сопоставляет порты на хосте — для этого при запуске контейнера используйте флаг `-p`.  
- Можно указать один порт:

EXPOSE 8080


Или несколько портов:

EXPOSE 8080 443



---

# Разница между ADD и COPY

| Инструкция | Описание                                                                                   |
|------------|--------------------------------------------------------------------------------------------|
| **ADD**    | Копирует файлы и папки в контейнер. Может загружать файлы из URL и распаковывать архивы `.tar`. |
| **COPY**   | Копирует только локальные файлы и папки из контекста сборки. Если целевая директория отсутствует, создаёт её. |

**Резюме:**  
- Используйте `COPY` для простого копирования локальных файлов.  
- Используйте `ADD` для загрузки из URL или распаковки архивов.

---


# Инструкции Dockerfile: FROM, RUN, COPY и ADD

Инструкции `FROM`, `RUN`, `COPY` и `ADD` используются для создания образа контейнера и выполняются последовательно, одна за другой.

- **FROM** задаёт базовый образ, например, дистрибутив Linux (Ubuntu, Debian, Alpine и др.).  
  Если образ отсутствует локально, Docker попытается скачать его из публичного или приватного реестра.

- **RUN** выполняет команды внутри контейнера во время сборки. Это могут быть установка ПО, создание файлов и настройка окружения.

- **COPY** копирует файлы и каталоги из контекста сборки (относительно Dockerfile) в файловую систему контейнера. Если целевая директория отсутствует, она будет создана.

- **ADD** похожа на `COPY`, но дополнительно может:  
  - копировать файлы из удалённых URL,  
  - распаковывать локальные архивы `.tar`.  
  Однако использование `ADD` с URL не рекомендуется из-за увеличения размера образа и невозможности обновления таких файлов[1][5][7].

---

# Оптимизация размера Docker-образа

Чтобы уменьшить размер образа, используйте следующие методы:

- **Выбор минимального базового образа**  
  Например, Alpine — лёгкий и компактный дистрибутив, подходящий для большинства приложений.

- **Сокращение количества слоёв**  
  Каждая инструкция создаёт слой, увеличивая размер. Объединяйте команды в одну, где это возможно.

- **Очистка промежуточных данных**  
  После установки пакетов удаляйте временные файлы и кеши.

- **Использование файла `.dockerignore`**  
  Исключайте из контекста ненужные файлы и каталоги, чтобы не передавать их в сборку.

- **Настройка времени выполнения**  
  Оптимизируйте параметры запуска контейнера для повышения производительности.

---

# Управление контейнерами

- Запуск контейнера из образа:

docker run [опции] <образ>



Для запуска в фоновом режиме используйте ключ `-d`:

docker run -d <образ>



- Выполнение команды внутри запущенного контейнера:

docker exec -it <container_id_or_name> <команда>



Например, запуск оболочки:

docker exec -it <container_id_or_name> bash



- Удаление контейнера:

docker rm <container_id_or_name>



Для принудительного удаления работающего контейнера добавьте ключ `-f`:

docker rm -f <container_id_or_name>



---

# Просмотр списков контейнеров и образов

- Список запущенных контейнеров:

docker ps



- Список всех контейнеров (включая остановленные):

docker ps -a



- Список всех образов (включая промежуточные слои):

docker images -a



- Список неиспользуемых (dangling) образов:

docker images -f dangling=true



---

# Очистка контейнеров и томов

- Удаление контейнеров по ID или имени:

docker rm <container_id_or_name>



- Удаление всех завершённых контейнеров:

docker rm $(docker ps -a -f status=exited -q)



- Работа с томами:

- Просмотр всех томов:

  ```
  docker volume ls
  ```

- Удаление тома по имени:

  ```
  docker volume rm <volume_name>
  ```

- Просмотр томов, не связанных с контейнерами:

  ```
  docker volume ls -f dangling=true
  ```

- Удаление всех "висячих" томов:

  ```
  docker volume prune
  ```

---

#  по ADD и COPY

| Инструкция | Возможности                                                                                   |
|------------|----------------------------------------------------------------------------------------------|
| **COPY**   | Копирует локальные файлы и каталоги из контекста сборки в образ. Создаёт директории при необходимости. |
| **ADD**    | Помимо функций `COPY`, может скачивать файлы по URL и распаковывать локальные `.tar` архивы. |

> Рекомендуется использовать `COPY` для простого копирования локальных файлов и только при необходимости применять `ADD`[1][3][5][7][8].

---



# Образы с меткой `<none>`

Образы с меткой `<none>` в выводе команды `docker images` — это висящие (dangling) или непомеченные образы Docker.

- **Висящий образ** — это образ, созданный в результате новой сборки, но не получивший имя или тег.  
- Старые образы, которые остались в локальном репозитории, теряют связь с именем репозитория или тегом и отображаются как `<none>`.

Такие образы могут быть промежуточными слоями или "мусором", который занимает место, но не используется напрямую. Для очистки можно использовать команды вроде `docker image prune` или удалять вручную[1][3][5][7].

---

# Переменные окружения в Docker

## Определение переменных в Dockerfile

Переменные окружения задаются на этапе создания образа с помощью инструкции:

ENV <ключ>=<значение>



## Переопределение при запуске контейнера

Для переопределения переменных при запуске контейнера используйте флаг `-e`:

docker run -e APP_MODE=production <образ>



## Использование файла `.env`

Если переменных много, удобно хранить их в файле `.env`. Для подключения файла используйте ключ `--env-file`:

docker run --env-file .env <образ>



## Передача переменных через Docker Compose

Docker Compose позволяет запускать несколько контейнеров и передавать переменные окружения через файл `docker-compose.yml` или `.env`.

> Переменные окружения нельзя изменить "на лету". Для изменения нужно остановить контейнер и запустить его с новыми значениями.

---

# Проброс портов (порт-маппинг)

Проброс портов — связывание порта контейнера с портом хоста, чтобы обеспечить доступ к контейнеру извне.

- Для проброса порта используйте флаг `-p`:

docker run -p <порт_хоста>:<порт_контейнера> <образ>



- Пример:

docker run -p 8080:80 my_docker_image



Здесь порт 80 контейнера доступен на порту 8080 хоста.

- Для проброса нескольких портов добавляйте несколько флагов `-p`:

docker run -p 8080:80 -p 443:443 my_docker_image



- В Docker Compose проброс портов настраивается директивой `ports` в `docker-compose.yml`.

- Если на хосте не установлен `iptables`, можно использовать альтернативы: `nftables`, `bridge-utils`, или утилиты вроде `socat` для проброса портов вручную.

---

# Тома Docker

Том — это способ постоянного хранения данных, которые могут использоваться одним или несколькими контейнерами.

- В отличие от данных внутри контейнера, тома **не удаляются** при остановке или удалении контейнера.

## Преимущества томов

- **Долговременное хранение** — данные сохраняются между запусками контейнера.  
- **Универсальный доступ** — тома могут быть примонтированы к нескольким контейнерам одновременно.  
- **Простота использования** — Docker автоматически управляет томами.

## Типы томов

| Тип тома      | Описание                                                                                 |
|--------------|------------------------------------------------------------------------------------------|
| **Docker Volumes** | Стандартные тома, хранящиеся в специальной директории Docker на хосте.                  |
| **Bind Mounts**    | Связывает директорию на хосте с директорией в контейнере. Используется для интеграции локальных данных. |
| **Tmpfs Mounts**   | Хранит данные только в памяти, сбрасывается при перезапуске контейнера. Подходит для временных данных. |

## Места монтирования томов

- **На хосте** — локальное хранение данных.  
- **На сервере или в облаке** — с помощью драйверов можно подключать удалённые тома, не меняя логику работы контейнера.

---


# Драйверы логов в Docker

Docker поддерживает несколько драйверов логов, которые определяют, куда и как сохраняются логи контейнеров:

- **json-file** — драйвер по умолчанию, сохраняет логи в формате JSON на локальном хосте.  
- **syslog** — отправляет логи в системный демон syslog для централизованной обработки.  
- **journald** — использует системный журнал systemd для хранения логов.  
- **gelf** — отправляет логи в формате Graylog Extended Log Format (GELF).  
- **fluentd** — интеграция с Fluentd, системой сбора и агрегации логов.  
- **awslogs** — отправляет логи в Amazon CloudWatch Logs.

Для настройки драйвера логов по умолчанию используется конфигурация Docker-демона (`daemon.json`), а для конкретного контейнера — опция `--log-driver` при запуске.

---

# Просмотр логов контейнера

- Для просмотра логов в реальном времени используйте команду:

docker logs -f <container_id_or_name>



- Для удобного просмотра логов и мониторинга можно использовать платформы, например, Dockhost. В интерфейсе Dockhost перейдите в раздел «Контейнеры», выберите нужный контейнер и откройте вкладку «Логи».

---

# Healthchecks в Docker

Инструкция `HEALTHCHECK` позволяет автоматически проверять состояние приложения внутри контейнера.

### Синтаксис:

HEALTHCHECK [OPTIONS] CMD <команда_проверки>



- **CMD** — команда для проверки состояния (например, проверка ответа сервера или наличие файла).  
- **OPTIONS** — дополнительные параметры:

  - `--interval=<duration>` — интервал между проверками (по умолчанию 30 секунд).  
  - `--timeout=<duration>` — максимальное время выполнения команды (по умолчанию 30 секунд).  
  - `--retries=<count>` — количество неудачных попыток до признания контейнера нездоровым (по умолчанию 3).  
  - `--start-period=<duration>` — время ожидания перед началом проверок (по умолчанию 0 секунд).

Healthchecks помогают контролировать работоспособность контейнера и позволяют Docker автоматически реагировать на сбои (перезапускать контейнер или уведомлять об ошибках).

---

# Ограничение ресурсов контейнера

В Kubernetes можно ограничивать ресурсы контейнера:

- **Запросы (requests)** — минимальные ресурсы, необходимые для работы приложения.  
- **Лимиты (limits)** — максимальные ресурсы, которые контейнер может использовать.

По умолчанию:  
- Лимит памяти — 512MiB.  
- Лимит CPU — не установлен.

Контейнеры, превышающие лимит CPU, будут ограничены, а при превышении лимита памяти могут быть остановлены.

---

# Запуск контейнеров с непривилегированным пользователем

По умолчанию Docker-контейнеры запускаются от пользователя `root` внутри контейнера, что может быть опасно:

- **Безопасность:** если контейнер скомпрометирован, злоумышленник получает права суперпользователя внутри контейнера.  
- **Ошибки конфигурации:** запуск с флагом `--privileged` даёт контейнеру доступ к ресурсам хоста, что увеличивает риски.  
- **Принцип наименьших привилегий:** приложениям редко нужны права `root`. Запуск с `root` может привести к ошибкам и злоупотреблениям.  
- **Права на хосте при монтировании:** `root` внутри контейнера может модифицировать файлы на хосте с привилегиями суперпользователя.

### Рекомендации:

- Используйте флаг `--user` при запуске контейнера, чтобы указать непривилегированного пользователя:

docker run --user <uid>:<gid> <образ>



- В Dockerfile используйте инструкцию `USER` для смены пользователя по умолчанию:

USER <username>



---

# Docker squash

Для уменьшения размера образа можно объединить слои с помощью опции `--squash`:

docker build --squash -t <образ> .



---

# Разница между `docker stop` и `docker pause`

| Команда       | Описание                                                                                       |
|---------------|------------------------------------------------------------------------------------------------|
| **docker stop**  | Посылает контейнеру сигнал `SIGTERM`, затем `SIGKILL`, после чего контейнер останавливается.   |
| **docker pause** | Приостанавливает процессы внутри контейнера (замораживает), но не освобождает ресурсы.        |

---

# Завершение контейнера изнутри

Чтобы убить контейнер изнутри, завершите его основной процесс (PID 1), например:

kill 1



Или снаружи используйте:

docker kill <container_id_or_name>



---










