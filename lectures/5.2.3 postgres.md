###  PostgreSQL

PostgreSQL — это мощная, объектно-реляционная система управления базами данных (ОРСУБД) с открытым исходным кодом, известная своей надежностью, гибкостью и соответствием стандартам SQL.

#### Развертывание и настройка PostgreSQL

**1. Установка PostgreSQL (пример для Debian/Ubuntu):**

```bash
sudo apt update
sudo apt install postgresql postgresql-contrib
```

После установки PostgreSQL сервер обычно запускается автоматически.

**2. Подключение к PostgreSQL:**

По умолчанию создается пользователь `postgres` с правами суперпользователя. Подключиться к командной строке PostgreSQL (`psql`) можно так:

```bash
sudo -u postgres psql
```

Вы попадете в интерактивную оболочку `psql`. Для выхода введите `\q`.

**3. Создание базы данных:**

Внутри `psql` (под пользователем `postgres` или другим пользователем с соответствующими правами):

```sql
CREATE DATABASE mydatabase;
```

Или из командной строки Linux:

```bash
sudo -u postgres createdb mydatabase
```

**4. Создание пользователей и прав:**

**Создание пользователя (роли):**

Внутри `psql`:

```sql
CREATE USER myuser WITH PASSWORD 'mypassword';
-- Или, для создания пользователя, который может входить в систему:
-- CREATE ROLE myuser LOGIN PASSWORD 'mypassword';
```

**Предоставление прав пользователю на базу данных:**

```sql
-- Предоставить все права на базу данных 'mydatabase' пользователю 'myuser'
GRANT ALL PRIVILEGES ON DATABASE mydatabase TO myuser;
```

**Предоставление прав на конкретные таблицы (если они уже существуют):**

```sql
-- Подключитесь к нужной базе данных: \c mydatabase
-- Предоставить права на выборку, вставку, обновление, удаление для таблицы 'mytable'
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE mytable TO myuser;
-- Предоставить права на все таблицы в схеме 'public' (часто используется по умолчанию)
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO myuser;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO myuser; -- Для автоинкрементных полей
GRANT ALL PRIVILEGES ON ALL FUNCTIONS IN SCHEMA public TO myuser;
```

**Изменение владельца базы данных:**

```sql
ALTER DATABASE mydatabase OWNER TO myuser;
```

**5. Импорт/Экспорт данных:**

**Экспорт (Dump):**

*   **`pg_dump`** - утилита для создания резервной копии (дампа) базы данных.

    *   **Экспорт всей базы данных в текстовом формате (SQL-команды):**
        ```bash
        pg_dump -U username -h hostname -p portnumber databasename > backup.sql
        # Пример для локального пользователя postgres:
        sudo -u postgres pg_dump mydatabase > mydatabase_backup.sql
        ```

    *   **Экспорт в кастомном формате (рекомендуется для больших баз, позволяет выборочное восстановление):**
        ```bash
        sudo -u postgres pg_dump -Fc mydatabase > mydatabase_backup.dump
        # -Fc означает "custom format"
        ```

    *   **Экспорт одной таблицы:**
        ```bash
        sudo -u postgres pg_dump -t mytable mydatabase > mytable_backup.sql
        ```

    *   **Экспорт только схемы (без данных):**
        ```bash
        sudo -u postgres pg_dump -s mydatabase > mydatabase_schema.sql
        ```

    *   **Экспорт только данных (без схемы):**
        ```bash
        sudo -u postgres pg_dump -a mydatabase > mydatabase_data.sql
        ```

**Импорт (Restore):**

*   **`psql`** - для восстановления из текстовых SQL-дампов.
*   **`pg_restore`** - для восстановления из кастомных, tar, или directory форматов, созданных `pg_dump`.

    *   **Импорт из текстового SQL-файла:**
        Сначала создайте пустую базу данных (если ее нет):
        ```bash
        sudo -u postgres createdb newdatabase
        ```
        Затем импортируйте:
        ```bash
        sudo -u postgres psql newdatabase < mydatabase_backup.sql
        ```
        Или внутри `psql`:
        ```sql
        \c newdatabase
        \i /path/to/mydatabase_backup.sql
        ```

    *   **Импорт из кастомного формата (`.dump`):**
        Сначала создайте пустую базу данных (если ее нет).
        ```bash
        sudo -u postgres createdb newdatabase
        ```
        Затем используйте `pg_restore`:
        ```bash
        sudo -u postgres pg_restore -d newdatabase mydatabase_backup.dump
        # -d указывает целевую базу данных
        ```
        Если дамп содержит команды создания базы данных или вы хотите восстановить с определенными опциями, `pg_restore` очень гибок.

**6. Дамп и Рестор (Резервное копирование и восстановление):**

Это по сути те же команды `pg_dump` и `pg_restore`/`psql`, которые описаны выше.

**Ключевые моменты для резервного копирования:**

*   **Регулярность:** Настройте автоматическое резервное копирование (например, через cron).
*   **Хранение:** Храните резервные копии в безопасном месте, желательно на другом физическом носителе или в облаке.
*   **Тестирование восстановления:** Периодически проверяйте, что вы можете успешно восстановить данные из резервных копий.
*   **Типы дампов:**
    *   **Логический дамп (`pg_dump`):** Создает SQL-скрипты или архивные файлы. Гибкий, позволяет восстанавливать на разных версиях PostgreSQL и архитектурах.
    *   **Физическое резервное копирование (File system level backup):** Копирование файлов данных PostgreSQL. Быстрее для очень больших баз, но менее гибкое (обычно требует той же версии и архитектуры).
    *   **Непрерывное архивирование и восстановление на определенный момент времени (Point-in-Time Recovery - PITR):** Использует базовую резервную копию и архивированные WAL (Write-Ahead Logging) файлы для восстановления состояния базы данных на любой момент времени. Это более сложная, но очень мощная стратегия.

**Пример простого скрипта для ежедневного бэкапа:**

```bash
#!/bin/bash
DB_NAME="mydatabase"
BACKUP_DIR="/var/backups/postgresql"
DATE=$(date +%Y-%m-%d_%H-%M-%S)

# Создаем директорию, если не существует
mkdir -p $BACKUP_DIR

# Делаем дамп
sudo -u postgres pg_dump -Fc $DB_NAME > "$BACKUP_DIR/${DB_NAME}_${DATE}.dump"

# (Опционально) Удаляем старые бэкапы, например, старше 7 дней
find $BACKUP_DIR -type f -name "*.dump" -mtime +7 -delete
```
Не забудьте сделать скрипт исполняемым (`chmod +x script.sh`) и добавить его в cron.

**7. Основные настройки оптимизации PostgreSQL:**

Файл конфигурации PostgreSQL обычно находится в `/etc/postgresql/<version>/main/postgresql.conf`. После изменений в этом файле требуется перезагрузка сервера PostgreSQL (`sudo systemctl restart postgresql`).

**Важно:** Прежде чем изменять эти параметры, тщательно изучите их влияние. Неправильные настройки могут ухудшить производительность или привести к нестабильной работе. Начинайте с небольших изменений и тестируйте.

*   **`shared_buffers`**:
    *   Определяет объем памяти, который PostgreSQL использует для кэширования данных.
    *   Рекомендация: обычно 25% от общего объема оперативной памяти системы. Для выделенных серверов баз данных может быть больше (до 40%).
    *   Пример: `shared_buffers = 2GB` (если у вас 8GB RAM).

*   **`work_mem`**:
    *   Объем памяти, используемый для внутренних операций сортировки, хэширования и других операций перед записью на диск.
    *   Устанавливается для каждого соединения/операции. Слишком высокое значение может привести к нехватке памяти, если много одновременных сложных запросов.
    *   Начинайте с небольших значений (например, 4MB-16MB) и увеличивайте, если видите, что сложные запросы часто пишут временные файлы на диск (можно отслеживать через `EXPLAIN ANALYZE`).
    *   Пример: `work_mem = 16MB`

*   **`maintenance_work_mem`**:
    *   Объем памяти, используемый для операций обслуживания, таких как `VACUUM`, `CREATE INDEX`, `ALTER TABLE ADD FOREIGN KEY`.
    *   Может быть установлен выше, чем `work_mem`, так как эти операции обычно не выполняются параллельно в большом количестве.
    *   Пример: `maintenance_work_mem = 256MB`

*   **`effective_cache_size`**:
    *   Оценка общего объема памяти, доступного для кэширования данных (включая `shared_buffers` и кэш операционной системы).
    *   Помогает планировщику запросов оценить, будут ли данные в кэше.
    *   Рекомендация: 50-75% от общего объема RAM.
    *   Пример: `effective_cache_size = 6GB` (если у вас 8GB RAM).

*   **`wal_buffers`**:
    *   Размер буфера для WAL (Write-Ahead Log) записей перед их записью на диск.
    *   Значение по умолчанию (`-1`) обычно устанавливает его в `1/32` от `shared_buffers` (но не менее `64kB` и не более `16MB`). Обычно значение по умолчанию подходит. Увеличение может помочь при высокой нагрузке на запись.
    *   Пример: `wal_buffers = 16MB` (если `shared_buffers` достаточно большой).

*   **`checkpoint_completion_target`**:
    *   Определяет, как быстро должен быть завершен процесс контрольной точки (checkpoint) в процентах от времени между контрольными точками.
    *   Значение `0.9` (по умолчанию `0.5` до PostgreSQL 9.5, `0.9` с 9.6+) распределяет нагрузку ввода-вывода от checkpoint на более длительный период, сглаживая пики.
    *   Пример: `checkpoint_completion_target = 0.9`

*   **`random_page_cost`**:
    *   Стоимость чтения случайной страницы с диска для планировщика запросов.
    *   Если у вас быстрые диски (SSD), вы можете уменьшить это значение (по умолчанию `4.0`) до `1.1` - `2.0`, чтобы планировщик чаще выбирал индексное сканирование.
    *   Пример: `random_page_cost = 1.1` (для SSD)

*   **`seq_page_cost`**:
    *   Стоимость чтения последовательной страницы с диска (по умолчанию `1.0`). Обычно не требует изменения.

*   **`max_connections`**:
    *   Максимальное количество одновременных подключений к серверу.
    *   Каждое соединение потребляет память. Увеличивайте с осторожностью. Часто лучше использовать пул соединений (connection pooler) вроде PgBouncer или Pgpool-II, чем устанавливать очень большое значение `max_connections`.
    *   Пример: `max_connections = 200`

*   **`autovacuum`**:
    *   Автоматический процесс очистки "мертвых" кортежей и анализа таблиц. Очень важно, чтобы он был включен (`autovacuum = on` по умолчанию). Настройки `autovacuum_max_workers`, `autovacuum_naptime` и пороговые значения для таблиц могут потребовать тюнинга для очень активных баз данных.

**Инструменты для анализа производительности:**

*   `EXPLAIN ANALYZE query;`: Показывает план выполнения запроса и реальное время выполнения. Используйте для выявления "узких мест" в запросах.
*   `pg_stat_statements`: Модуль, который отслеживает статистику выполнения всех SQL-запросов. Требует добавления в `shared_preload_libraries` в `postgresql.conf` и создания расширения (`CREATE EXTENSION pg_stat_statements;`).
*   `pg_buffercache`: Модуль для просмотра содержимого `shared_buffers`.
*   Логи PostgreSQL: Содержат информацию об ошибках, медленных запросах (`log_min_duration_statement`), блокировках и т.д.

