# Course dev - processes - Sasha

Что такое процесс?

Процесс -это экземпляр программы, выполняемой в системе. Для каждой запускаемой программы создается отдельный процесс. В рамках процесса программе выделяется процессорное время, оперативная память и другие системные ресурсы. У каждого процесса есть свой идентификатор, Proccess ID или просто PID, по ним, чаще всего и определяются процессы Linux. PID определяется неслучайно, как я уже говорил, программа инициализации получает PID 1, а каждая следующая запущенная программа - на единицу больше. Таким образом PID пользовательских программ доходит уже до нескольких тысяч.


Чтобы найти запущенные процессы в Linux, можно использовать команду ps. Она отображает информацию о текущих процессах в системе. ps — показывает процессы, которые запущены в текущем сеансе пользователя.  

•	ps aux — предоставляет более подробную информацию о процессах. Вывод включает PID, пользователю, который запустил процесс, использование процессора и памяти, время работы и команду, которая была выполнена.  
•	ps -ef — похож на ps aux, но отображает информацию в другом формате.  
•	ps -имя пользователя — отображает процессы, принадлежащие определённому пользователю.  
•	ps -p PID — отображает информацию о конкретном процессе по его PID.  
Для мониторинга процессов в Linux также можно использовать команды top или htop. Например, команда top выводит на экран список работающих процессов в реальном времени.   

Чтобы завершить процесс в Linux, используется команда kill. Она отправляет сигнал процессу для его завершения. 

•	kill <PID> — завершает процесс по его PID.   

•	kill -9 <PID> — принудительно завершает процесс, используя сигнал SIGKILL.   

•	killall <имя_процесса> — завершает все процессы с определённым именем.   






Жизненный цикл процесса 

![image](https://github.com/user-attachments/assets/753ac582-d1cb-4de2-8821-b5be54baef70)


 

Рождение процесса


Только один процесс в системе рождается особенным способом — init — он порождается непосредственно ядром. Все остальные процессы появляются путём дублирования текущего процесса с помощью системного вызова fork(2). После выполнения fork(2) получаем два практически идентичных процесса за исключением следующих пунктов:

1.	fork(2) возвращает родителю PID ребёнка, ребёнку возвращается 0;
   
3.	У ребёнка меняется PPID (Parent Process Id) на PID родителя.
   

После выполнения fork(2) все ресурсы дочернего процесса — это копия ресурсов родителя. Копировать процесс со всеми выделенными страницами памяти — дело дорогое, поэтому в ядре Linux используется технология Copy-On-Write.
Все страницы памяти родителя помечаются как read-only и становятся доступны и родителю, и ребёнку. Как только один из процессов изменяет данные на определённой странице, эта страница не изменяется, а копируется и изменяется уже копия. Оригинал при этом «отвязывается» от данного процесса. Как только read-only оригинал остаётся «привязанным» к одному процессу, странице вновь назначается статус read-write.




Состояние «готов»


Сразу после выполнения fork(2) переходит в состояние «готов».
Фактически, процесс стоит в очереди и ждёт, когда планировщик (scheduler) в ядре даст процессу выполняться на процессоре.




Состояние «выполняется»


Как только планировщик поставил процесс на выполнение, началось состояние «выполняется». Процесс может выполняться весь предложенный промежуток (квант) времени, а может уступить место другим процессам, воспользовавшись системным вывозом sched_yield.




Перерождение в другую программу


В некоторых программах реализована логика, в которой родительский процесс создает дочерний для решения какой-либо задачи. Ребёнок в данном случае решает какую-то конкретную проблему, а родитель лишь делегирует своим детям задачи. Например, веб-сервер при входящем подключении создаёт ребёнка и передаёт обработку подключения ему.
Однако, если нужно запустить другую программу, то необходимо прибегнуть к системному вызову execve(2):


int execve(const char *filename, char *const argv[], char *const envp[]);



или библиотечным вызовам execl(3), execlp(3), execle(3), execv(3), execvp(3), execvpe(3):



int execl(const char *path, const char *arg, ... /* (char  *) NULL */);


int execlp(const char *file, const char *arg, ...  /* (char  *) NULL */);


int execle(const char *path, const char *arg, ...


                             /*, (char *) NULL, char * const envp[] */);

		
int execv(const char *path, char *const argv[]);


int execvp(const char *file, char *const argv[]);


int execvpe(const char *file, char *const argv[], char *const envp[]);



Все из перечисленных вызовов выполняют программу, путь до которой указан в первом аргументе. В случае успеха управление передаётся загруженной программе и в исходную уже не возвращается. При этом у загруженной программы остаются все поля структуры процесса, кроме файловых дескрипторов, помеченных как O_CLOEXEC, они закроются.


Как не путаться во всех этих вызовах и выбирать нужный? Достаточно постичь логику именования:

•	Все вызовы начинаются с exec

•	Пятая буква определяет вид передачи аргументов:


o	l обозначает list, все параметры передаются как arg1, arg2, ..., NULL

o	v обозначает vector, все параметры передаются в нуль-терминированном массиве;

•	Далее может следовать буква p, которая обозначает path. Если аргумент file начинается с символа, отличного от "/", то указанный file ищется в каталогах, перечисленных в переменной окружения PATH

•	Последней может быть буква e, обозначающая environ. В таких вызовах последним аргументом идёт нуль-терминированный массив нуль-терминированных строк вида key=value — переменные окружения, которые будут переданы новой программе.




Состояние «ожидает»


Некоторые системные вызовы могут выполняться долго, например, ввод-вывод. В таких случаях процесс переходит в состояние «ожидает». Как только системный вызов будет выполнен, ядро переведёт процесс в состояние «готов».

В Linux так же существует состояние «ожидает», в котором процесс не реагирует на сигналы прерывания. В этом состоянии процесс становится «неубиваемым», а все пришедшие сигналы встают в очередь до тех пор, пока процесс не выйдет из этого состояния.
Ядро само выбирает, в какое из состояний перевести процесс. Чаще всего в состояние «ожидает (без прерываний)» попадают процессы, которые запрашивают ввод-вывод. Особенно заметно это при использовании удалённого диска (NFS) с не очень быстрым интернетом.




Состояние «остановлен»


В любой момент можно приостановить выполнение процесса, отправив ему сигнал SIGSTOP. Процесс перейдёт в состояние «остановлен» и будет находиться там до тех пор, пока ему не придёт сигнал продолжать работу (SIGCONT) или умереть (SIGKILL). Остальные сигналы будут поставлены в очередь.




Завершение процесса


Ни одна программа не умеет завершаться сама. Они могут лишь попросить систему об этом с помощью системного вызова _exit или быть завершенными системой из-за ошибки. Даже когда возвращаешь число из main(), всё равно неявно вызывается _exit.
Хотя аргумент системного вызова принимает значение типа int, в качестве кода возврата берется лишь младший байт числа.




Состояние «зомби»


Сразу после того, как процесс завершился (неважно, корректно или нет), ядро записывает информацию о том, как завершился процесс и переводит его в состояние «зомби». Иными словами, зомби — это завершившийся процесс, но память о нём всё ещё хранится в ядре.
Более того, это второе состояние, в котором процесс может смело игнорировать сигнал SIGKILL, ведь что мертво не может умереть ещё раз.



Способы устранения зомби:


•	Отправка сигнала SIGCHLD родительскому процессу.

•	Завершение родительского процесса, если это допустимо




Забытье



Код возврата и причина завершения процесса всё ещё хранится в ядре и её нужно оттуда забрать. Для этого можно воспользоваться соответствующими системными вызовами:



pid_t wait(int *wstatus); /       * Аналогично waitpid(-1, wstatus, 0) */



pid_t waitpid(pid_t pid, int *wstatus, int options);





Как запускать процессы фоном


Для запуска процессов в фоновом режиме используются следующие методы:

1.	Добавление символа & после команды:
   
                             command &
Процесс будет запущен в фоне.



2.	Использование команды nohup, чтобы процесс продолжал работать после закрытия терминала:
   
                            nohup command &



3.	Переведите уже запущенный процесс в фоновый режим с помощью комбинации клавиш Ctrl+Z, а затем команды bg.










